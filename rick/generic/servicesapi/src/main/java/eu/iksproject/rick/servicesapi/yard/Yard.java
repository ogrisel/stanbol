package eu.iksproject.rick.servicesapi.yard;

import eu.iksproject.rick.servicesapi.Rick;
import eu.iksproject.rick.servicesapi.model.EntityMapping;
import eu.iksproject.rick.servicesapi.model.Reference;
import eu.iksproject.rick.servicesapi.model.Representation;
import eu.iksproject.rick.servicesapi.model.Symbol;
import eu.iksproject.rick.servicesapi.model.Text;
import eu.iksproject.rick.servicesapi.model.ValueFactory;
import eu.iksproject.rick.servicesapi.query.FieldQuery;
import eu.iksproject.rick.servicesapi.query.FieldQueryFactory;
import eu.iksproject.rick.servicesapi.query.QueryResultList;
import eu.iksproject.rick.servicesapi.site.ReferencedSite;
import eu.iksproject.rick.servicesapi.site.ReferencedSiteManager;


/**
 * <p>The Yard represents a local cache for {@link Representation}s of the Entities
 * and Symbols managed by a referenced site.<p>
 *
 * <p> Referenced Sites need to provide the configuration if there representations
 * should be cached locally. This is done by using one of the defined {@link CacheStrategy}.
 *
 * <p>The Idea is not to have one big Yard that caches all the representations, but
 * to provide the possibility to use different caches. This means, that each
 * {@link ReferencedSite} can have its own Yard instance. However
 * several Sites might also use the same Yard.</p>
 * <p>The {@link YardManager} is an singleton services that manages the different
 * Yard instances and provides an central point of access for the {@link Rick}
 * and the {@link ReferencedSiteManager}.</p>
 *
 * <p> This should also allow for implementing Yards that are based on
 * <ul>
 * <li> Indexes generated by dumps of the referred Site</li>
 * <li> local installations of the software used by the referred site</li>
 * <li> and so on ... </li>
 * </ul>
 *
 * TODO: The framework need to provide a special Yard for storing {@link Symbol}
 * and {@link EntityMapping} information. This Yard is currently referenced as
 * Rick-Yard. Do we need also a special API for this Yard?
 * One could still provide a "default" implementation that implements this
 * interface based on a Component that provides the normal {@link Yard} service.
 * <p/>
 * <p>Side note: The name yard was chosen because in farming the word "rick"
 * was used to describe small bales of Hay or Corn that are stacked in a
 * criss-crossed fashion. The word "rick yard" describes a farm-yard containing
 * ricks of hay or corn.</p>
 *
 * @author Rupert Westenthaler
 *         <p/>
 *         TODO: Need to decide how Yards are linked to the Site for which they
 *         cache entities.
 */
public interface Yard {

    String ID = "eu.iksproject.rick.yard.id";
    String NAME = "eu.iksproject.rick.yard.name";
    String DESCRIPTION = "eu.iksproject.rick.yard.description";

    /**
     * Getter for the unique ID of the Yard (within the local rick node)
     *
     * @return the id
     */
    String getId();

    String getName();

    String getDescription();

    /**
     * Creates a new representation. The Yard is responsible to assign a valid
     * ID.
     *
     * @return the created Representation initialised with a valid ID
     */
    Representation create();

    /**
     * Creates a new representation for the given id
     *
     * @param id the id for the new representation or <code>null</code> to
     * indicate that the Yard should assign an id.
     * @return the created Representation
     * @throws IllegalArgumentException if the parsed id is not valid or there
     * exists already a representation with the parsed id.
     */
    Representation create(String id) throws IllegalArgumentException;

    /**
     * Stores the representation in the Yard. if the parsed representation is
     * not present in the Yard it will add it to the Yard.
     *
     * @param representation the representation
     * @return the representation as stored
     * @throws IllegalArgumentException if <code>null</code> is parsed as argument or
     * the representation is not managed (e.g was not created by using this yard).
     * @throws YardException On any error related to the Yard
     */
    Representation store(Representation representation) throws IllegalArgumentException, YardException;

    /**
     * Stores all the parsed representation in a single chunk in the Yard. This
     * can improve performance, because it does not require multiple commits.<br>
     * <code>null</code> values are ignored and added as <code>null</code> in
     * the returned Iterable.
     * Otherwise same as {@link #store(Representation)}.
     *
     * @param representations all the representations to store
     * @return the stored representations in the same iteration order
     * @throws IllegalArgumentException if <code>null</code> is parsed as Iterable
     * @throws YardException On any error related to the Yard
     */
    Iterable<Representation> store(Iterable<Representation> representations) throws IllegalArgumentException, YardException;

    /**
     * Removes the {@link Representation} with the given id
     *
     * @param id the id
     * @throws IllegalArgumentException if the parsed ID is null or not valid
     * formatted
     * @throws YardException On any error related to the Yard
     */
    void remove(String id) throws IllegalArgumentException, YardException;

    /**
     * Removes all the {@link Representation} of the parsed ids. <code>null</code>
     * values are ignored.
     *
     * @param ids the iterable over the ids to remove
     * @throws IllegalArgumentException if <code>null</code> is parsed as iterable
     * @throws YardException On any error related to the Yard
     */
    void remove(Iterable<String> ids) throws IllegalArgumentException, YardException;

    /**
     * checks if a representation with the given id is present in the Yard
     *
     * @param id the id. Calls with <code>null</code> are ignored
     * @return <code>true</code> if a representation with the id is present in
     *         the Yard. Otherwise <code>false</code>.
     * @throws IllegalArgumentException if the parsed ID is not valid
     * formatted
     * @throws YardException On any error related to the Yard
     */
    boolean isRepresentation(String id) throws YardException, IllegalArgumentException;

    /**
     * Getter for the representation based on the id. Calls with
     * <code>id = null</code> should return null.
     *
     * @param id the id.
     * @return The representation with the parsed id or <code>null</code> if
     *         no representation with this id is present in the Yard
     * @throws IllegalArgumentException if the parsed ID is not valid
     * formatted
     * @throws YardException On any error related to the Yard
     */
    Representation getRepresentation(String id) throws YardException, IllegalArgumentException;

    /**
     * Updates the store with the new state of the parsed representation
     *
     * @param represnetation the representation
     * @return the representation as stored
     * @throws IllegalArgumentException if the parsed representation <code>null</code>
     * or not present in the Yard
     * @throws YardException On any error related to the Yard
     */
    Representation update(Representation represnetation) throws YardException, IllegalArgumentException;

    /**
     * Updates the store with the new state of the parsed representations. This
     * can improve performance, because it does not require multiple commits.<br>
     * <code>null</code> values are ignored and added as <code>null</code> in
     * the returned Iterable. Otherwise same as {@link #update(Representation)}.
     *
     * @param representations the representations to update
     * @return the updated stored representations in the same iteration order
     * @throws YardException On any error related to the Yard
     * @throws IllegalArgumentException if <code>null</code> is parsed as Iterable
     */
    Iterable<Representation> update(Iterable<Representation> representations) throws YardException, IllegalArgumentException;

    /**
     * Finds all representations base on the parse query. Selected fields of the
     * query may be ignored, because only the ids of the found representations
     * are returned
     *
     * @param query The query
     * @return A ResultList containing the IDs of the found representations
     * @throws IllegalArgumentException if <code>null</code> is parsed as Query
     * @throws YardException On any error related to the Yard
     */
    QueryResultList<String> findReferences(FieldQuery query) throws YardException, IllegalArgumentException;

    /**
     * Getter for a view onto the Representations selected by the Query. Note
     * that the returned Representations will only include fields that are
     * selected by the parsed query. And such fields will only contain values
     * that are not filtered by the query.
     *
     * @param query the query
     * @return the view onto selected representations as defined by the query
     * @throws IllegalArgumentException if <code>null</code> is parsed as Query
     * @throws YardException On any error related to the Yard
     */
    QueryResultList<Representation> find(FieldQuery query) throws YardException, IllegalArgumentException;

    /**
     * Searches for all the Representation fulfilling the constraints of the
     * query and returns the (whole) representation as stored in the Yard.
     * Note that any as selected fields of the parsed query are ignored. Use
     * {@link #find(FieldQuery)} to retrieve representations that only contain
     * values for fields marked as selected by the parsed query.
     *
     * @param query the Query used to select representations in the Yard
     * @return the selected representations as stored in this yard.
     * @throws IllegalArgumentException if <code>null</code> is parsed as Query
     * @throws YardException On any error related to the Yard
     */
    QueryResultList<Representation> findRepresentation(FieldQuery query) throws YardException, IllegalArgumentException;

    /**
     * Getter for the FieldQueryFactory used by this Yard
     *
     * @return the FieldQueryFactory
     */
    FieldQueryFactory getQueryFactory();

    /**
     * Getter for the {@link ValueFactory} instance used by this Yard to create
     * {@link Representation}, {@link Reference} and {@link Text} instances.
     *
     * @return the valueFactory used by the store
     */
    ValueFactory getValueFactory();
/*
 * TODO: Maybe one would like to add status Information about cached
 *       Representations for registered Sites.
 */
// enum ProcessingStatus {
//        scheduled,
//        processing,
//        stored
//    };
//    ProcessingStatus getStatus(Site site);
//    ProcessingStatus getStatus(String entityId);
}
